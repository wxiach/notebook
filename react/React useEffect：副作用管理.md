# React useEffect：副作用管理

React 是一个用于构建用户界面的 JavaScript 库，它的核心理念之一是**组件化**。每个组件负责自己的一部分 UI 渲染，并在需要时与其他组件交互。在 React 中，我们提倡将每个组件设计为“纯函数”形式。什么是纯函数呢？简单来说，**纯函数**是指给定相同的输入，永远会返回相同的输出，并且不会产生任何副作用（比如改变外部变量、操作 DOM 或者发起网络请求等）。

然而，在实际应用中，我们常常需要执行一些副作用操作，比如获取数据、订阅事件、设置定时器等。**副作用**的概念非常重要，因为它决定了一个组件在渲染时会做哪些额外的事情，这些事情并不直接影响到组件的输出结果。

在 React 中，`useEffect` 就是用来处理副作用的工具，它让我们能够在组件渲染后执行这些副作用操作，同时保证组件的**纯粹性**。它不仅能够执行副作用，还能在组件卸载时清理副作用。

## 1. 为什么需要 `useEffect`？

要理解为什么 React 引入了 `useEffect`，我们首先需要理解 React 组件的渲染流程。React 是基于“声明式编程”思想的。什么是声明式编程呢？在声明式编程中，我们专注于描述“做什么”，而不是“如何做”。举个例子，如果你要在网页上显示一张图片，声明式编程方式是直接告诉 React：“我要显示这张图片”，而不是告诉它“如何去拿到图片，如何加载它等”。

React 的渲染本质上也是声明式的。组件根据当前的 props 和 state 来决定 UI 的显示方式，而不应该包含任何副作用。然而，实际的开发中，**副作用**（比如网络请求、订阅或 DOM 操作）是不可避免的。

`useEffect` 就是用来管理这些副作用的。当组件完成渲染后，我们用 `useEffect` 来执行这些副作用操作，并且能够确保它们在正确的时机执行，不会影响 UI 的渲染。

## 2. `useEffect` 的基本使用

`useEffect` 接受两个参数：第一个参数是一个函数，用于执行副作用；第二个参数是依赖数组，决定副作用的执行时机。

```javascript
useEffect(() => {
  // 副作用操作，如网络请求、订阅等
}, []) // 空数组表示副作用仅在组件挂载时执行一次
```

### 为什么要有依赖数组？

依赖数组是用来告诉 React，什么时候需要重新执行副作用。React 会根据数组中的值来决定是否重新执行副作用。如果数组为空 `[]`，则副作用仅在组件挂载时执行一次。如果数组中包含某些依赖项，当这些依赖项发生变化时，副作用就会重新执行。

## 3. 依赖项的三种传值情况

### 1. 空依赖数组 `[]`

如果依赖数组为空，副作用函数仅在组件第一次渲染时执行一次。

#### 示例：

```javascript
useEffect(() => {
  console.log('组件首次加载时执行')
}, []) // 仅在组件挂载时执行一次
```

#### 解析：

- `useEffect` 中的回调函数只会在组件挂载时执行一次，这意味着这个副作用（如日志打印）只会在组件渲染后第一次执行。
- 在这种情况下，`useEffect` 相当于 `componentDidMount`（类组件生命周期方法）的功能。

### 2. 不传依赖数组

如果没有传递第二个参数，副作用函数将在每次组件渲染后都执行。

#### 示例：

```javascript
useEffect(() => {
  console.log('组件每次渲染后都会执行')
}) // 没有依赖数组，每次渲染时都会执行
```

#### 解析：

- 由于没有传递依赖数组，`useEffect` 会在每次组件渲染后都执行副作用函数。
- 这种方式不常见，但有时也能用来执行一些需要每次渲染后都执行的操作，例如实时数据更新、用户输入监控等。

### 3. 依赖数组包含特定的 state 或 props

当依赖数组中包含某些 state 或 props 时，副作用函数会在这些依赖项发生变化时执行。

#### 示例：

```javascript
useEffect(() => {
  console.log('数据已更新:', data)
}, [data]) // 当 `data` 改变时执行副作用
```

#### 解析：

- `useEffect` 会监听 `data` 的变化，只有在 `data` 发生变化时，副作用函数才会重新执行。
- 这对于需要在数据更新时执行副作用的情况非常有用。例如，你可以用它来处理网络请求后的数据更新，或者在表单输入发生变化时实时更新显示。

## 4. 清理副作用

在某些情况下，我们需要在组件卸载时清理副作用。`useEffect` 提供了返回一个清理函数的机制，这个清理函数会在组件卸载或副作用依赖项发生变化时执行。

### 示例：清除定时器

```javascript
useEffect(() => {
  const timer = setInterval(() => {
    console.log('定时器执行中...')
  }, 1000)

  // 清理副作用
  return () => {
    clearInterval(timer)
  }
}, []) // 仅在组件挂载时启动定时器
```

#### 解析：

- `useEffect` 中的返回值是一个清理函数。在组件卸载时或者依赖项变化时，React 会调用这个清理函数。
- 在这个例子中，我们清除了定时器，防止定时器在组件卸载后继续执行，避免了内存泄漏。

## 5. 为什么 `useEffect` 能够帮助我们管理副作用？

`useEffect` 之所以重要，是因为它帮助我们在 React 中**按正确的时机执行副作用**。当我们编写 React 组件时，组件本身的渲染逻辑应该尽量保持**纯粹**，即仅依赖于传入的 props 和内部的 state 来渲染 UI。而副作用（例如发起 AJAX 请求、设置定时器、订阅事件等）是需要在渲染完成后执行的，而不是在渲染过程中。

`useEffect` 通过将副作用操作从渲染流程中提取出来，让我们可以在 React 组件的生命周期中指定副作用的执行时机。具体来说：

- 组件挂载时：可以执行一次性副作用（如发送请求、设置定时器等）。
- 依赖项变化时：可以响应数据变化，并重新执行副作用。
- 组件卸载时：可以清理定时器、取消订阅等，防止资源泄漏。

这种设计让我们能够在 React 中构建出更加清晰、可维护的组件，同时保持应用的高性能。

### 总结

- **空依赖数组 `[]`**：副作用仅在组件挂载时执行一次。
- **没有依赖数组**：副作用每次组件渲染时都执行。
- **包含依赖项**：副作用仅在依赖项变化时执行。

通过 `useEffect`，我们能够更加精确地控制副作用的执行时机，避免不必要的重复执行，并且能够在组件卸载时清理副作用，防止内存泄漏。理解并熟练掌握 `useEffect`，能够帮助我们编写更加高效和稳定的 React 组件。
