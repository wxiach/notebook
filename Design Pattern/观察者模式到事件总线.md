# 观察者模式到事件总线

> **写给未来的自己**：每次手敲事件模型都要 Google，干脆把思路和踩坑一次性记清楚。文章很长，都是唠叨，目的是让自己看两眼就能把设计理由找回来。

## 目录
1. 为什么我要折腾事件模型？
2. V0 ─ 单一事件的观察者模式
3. V1 ─ 多事件同步总线（类型拆分）
4. V2 ─ 订阅者优先级（链式调用可控）
5. V3 ─ 事件优先级 + 异步（削峰 & 隔离）
6. V4 ─ 组合式单线程总线（顺序极致保证）
7. 经验小抄

## 1｜为什么我要折腾事件模型？
* **耦合度**：把 if‑else 通知逻辑塞在同一个类里，一改就牵一大片，改怕了。
* **可测试性**：希望能单测“发一个事件 → 看谁收到了”，不用启动整套应用。
* **面试尬聊**：被问到“Spring ApplicationEvent 和 Observer 有啥区别”，含含糊糊很挫。

这篇就是把一次次“为什么要这样设计”写进代码注释里，别再年年忘。


## 2｜V0 ‑ 单一事件的观察者模式

> **场景**：只有一类消息，比如聊天窗口有人发言，监听者立刻打印出来。    
> **痛点**：一旦要支持第二种事件，就得复制粘贴另一套接口。

```java
// ========== MessageEvent ==========
// 最简单的 POJO，只有一条内容。后面会发现 Event 越写越胖，这里先别管。
public class MessageEvent {
    private final String content;
    public MessageEvent(String content) { this.content = content; }
    public String content() { return content; }
}

// ========== Listener ==========
// 单方法接口，本质就是 Java 版回调。
public interface Listener {
    void onMessage(MessageEvent e);
}

public class ConsolePrinter implements Listener {
    @Override public void onMessage(MessageEvent e) {
        // 业务写死：收到就打印。只演示用。
        System.out.println("[Printer] " + e.content());
    }
}

// ========== SimplePublisher ==========
// 最小发布者：仅负责遍历列表，没有任何顺序控制。
public class SimplePublisher {
    private final List<Listener> listeners = new ArrayList<>();

    public void addListener(Listener l) { listeners.add(l); }

    public void publish(String msg) {
        MessageEvent e = new MessageEvent(msg);
        // 顺序 = addListener 的顺序。这里没做保护性复制，线程安全靠调用方自觉。
        for (Listener l : listeners) l.onMessage(e);
    }
}
```

**总结**：
* 写起来爽，读起来爽，但一旦业务变复杂就原地报废。
* 发布者对订阅者的 *具体类型* 没有依赖，但依赖了“只有一种事件”的假设。


## 3｜V1 ‑ 多事件同步总线

> **目标**：让 Publisher 不关心 *到底是哪种事件*，把“事件‑订阅者”关系外提。

### 3.1 核心接口
```java
/** 所有事件的父类，加时间戳是为了调试时知道谁先谁后。 */
public abstract class Event {
    private final long createdAt = System.currentTimeMillis();
    public long createdAt() { return createdAt; }
}

/**
 * Subscriber 变成泛型：告诉编译器“我只吃哪种事件”，
 * 这样 onEvent 里面就能拿到强类型，不用到处强转。
 */
public interface Subscriber<E extends Event> {
    void onEvent(E event);

    /**
     * 返回自己关心的具体事件类型。为什么不用反射？
     *  → Java 的泛型擦除太坑，运行时拿不到 <E>，干脆让实现类手动说。
     */
    Class<E> subscribedType();
}
```

### 3.2 EventBus
```java
public class EventBus {
    // registry: 一个事件类型对应 N 个订阅者
    protected final Map<Class<?>, List<Subscriber<?>>> registry = new HashMap<>();

    /**
     * 注册时按事件类型分组。这里不用 Set，原因：
     * 1) 允许同类订阅者注册多次？看业务。  
     * 2) List 保持注册顺序，后面做优先级排序也方便。
     */
    public <E extends Event> void register(Subscriber<E> sub) {
        registry.computeIfAbsent(sub.subscribedType(), k -> new ArrayList<>())
                .add(sub);
    }

    /**
     * 同步派发：调用栈一路冒泡；如果订阅者抛异常就会影响后续订阅者。
     * 生产场景通常 try/catch 一下，或者用单独线程再包一层。
     */
    public void post(Event e) {
        // 如果没人关心这个事件，直接返回，省一次空循环。
        for (Subscriber<?> s : registry.getOrDefault(e.getClass(), List.of())) {
            invoke(s, e);
        }
    }

    @SuppressWarnings("unchecked")
    private <E extends Event> void invoke(Subscriber<E> s, Event e) {
        // 统一做 unchecked cast，避免调用处强转。这里只需相信调用者传的类型没错。
        s.onEvent((E) e);
    }
}
```

### 3.3 一个完整例子：用户注册
```java
/* ========= 事件定义 ========= */
public class UserCreatedEvent extends Event {
    private final String username;
    public UserCreatedEvent(String username) { this.username = username; }
    public String username() { return username; }
}

/* ========= 订阅者 ========= */
public class WelcomeMailSubscriber implements Subscriber<UserCreatedEvent> {
    @Override public void onEvent(UserCreatedEvent e) {
        System.out.println("发送欢迎邮件给 " + e.username());
    }
    @Override public Class<UserCreatedEvent> subscribedType() { return UserCreatedEvent.class; }
}
```

**这一步解决了什么？**
1. **多事件**：`EventBus` 自己维护事件 → 订阅者的映射；
2. **耦合降低**：发布方只依赖 `EventBus`，不知道也不想知道订阅者是谁；
3. **顺序依旧不可控**：谁先注册谁先执行。


## 4｜V2 ‑ 订阅者优先级

> **典型需求**：我想先记录日志，再做鉴权，再跑核心业务；不能光靠注册顺序——代码分散太容易写错。

### 4.1 给 Subscriber 加 order()
```java
/**
 * 继承再加一个默认方法，避免破坏旧实现。
 * 约定：数字越小，优先级越高（和 Spring 的 @Order 保持一致）。
 */
public interface OrderedSubscriber<E extends Event> extends Subscriber<E> {
    default int order() { return 0; }
}
```

### 4.2 有序的 EventBus
```java
public class OrderedEventBus extends EventBus {
    @Override public <E extends Event> void register(Subscriber<E> sub) {
        super.register(sub);
        // 重新排序：只在新增后动一次手脚，成本可接受。
        registry.get(sub.subscribedType())
                .sort(Comparator.comparingInt(s -> ((OrderedSubscriber<?>) s).order()));
    }
}
```

### 4.3 Demo
```java
public class AuditSubscriber implements OrderedSubscriber<UserCreatedEvent> {
    @Override public int order() { return -100; } // -100 < 0，所以先执行
    @Override public void onEvent(UserCreatedEvent e) {
        System.out.println("[Audit] 记录用户创建日志");
    }
    @Override public Class<UserCreatedEvent> subscribedType() { return UserCreatedEvent.class; }
}
```

**为什么要负数？** 纯个人喜好：核心业务默认 0，想让拦截器类提前就给负数，比手算顺序直观。

**痛点缓解**：
* 顺序写死在代码里，不怕换注册顺序；
* 还是同步，还是会被异常打断。


## 5｜V3 ‑ 事件优先级 + 异步调度

> **痛点**：同步派发会阻塞主线程；高并发下日志/指标这些非核心逻辑拖慢整体 RT。

### 5.1 事件带优先级
```java
public abstract class PriorityEvent extends Event implements Comparable<PriorityEvent> {
    /**
     * 越小越优先。为啥不用枚举？— 想兼顾“同优先级按时间戳先后”。
     */
    public int priority() { return 0; }

    @Override public int compareTo(PriorityEvent o) {
        int byPrio = Integer.compare(priority(), o.priority());
        return byPrio != 0 ? byPrio : Long.compare(createdAt(), o.createdAt());
    }
}
```

### 5.2 Dispatcher
```java
public class AsyncDispatcher {
    // PriorityBlockingQueue = JDK 自带有序阻塞队列，适合单线程消费场景。
    private final PriorityBlockingQueue<PriorityEvent> queue = new PriorityBlockingQueue<>();
    private final OrderedEventBus bus = new OrderedEventBus();
    private final ExecutorService worker = Executors.newSingleThreadExecutor();

    public AsyncDispatcher() {
        // 单线程循环：保证顺序；如果不怕乱序可换成多线程池。
        worker.submit(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                PriorityEvent e = queue.take(); // 阻塞直到有事件
                try {
                    bus.post(e);               // 订阅者内部已做优先级
                } catch (Exception ex) {
                    // 统一日志，避免把异常吞掉不好排查。
                    ex.printStackTrace();
                }
            }
        });
    }

    public void publish(PriorityEvent e) { queue.add(e); }
    public <E extends Event> void register(OrderedSubscriber<E> s) { bus.register(s); }
}
```

**这一步多做了什么？**
* **削峰**：主线程把事件扔队列就完事；
* **隔离**：订阅者异常只打印日志，不影响调用方；
* **延迟/重试**：可以在队列里边玩花活，例如“失败后重新入队 + priority += 10”。


## 6｜V4 ‑ 组合式单线程总线

> **极端顺序要求**：比如金融流水，必须“按发生顺序”+“拦截器顺序”双重保证。

```text
    PriorityBlockingQueue<Event>
              │  (按事件优先级 & 时间戳)
              ▼
        Single‑thread looper
              │  (while take())
              ▼
        OrderedEventBus.post()
              │  (按订阅者优先级)
              ▼
         真正业务逻辑
```

* 单线程消费带来顺序确定性，但吞吐受限，需要评估 QPS；
* 如果 QPS 撑不住，要么分片多队列，要么引入 Kafka 等有序 MQ。


## 7｜经验小抄

| 问题 | 个人做法 | 背后考虑 |
|------|----------|----------|
| **饥饿** | 给低优先级事件加 *最多等待 N 秒*，超时强制执行 | 避免高优先级雪崩时饿死低优先级 |
| **异常** | 同步：可以直接抛；异步：记录日志 + 死信队列 | 主线程可控 vs. 异步线程不能让任务 silently fail |
| **注册方式** | 手写 `bus.register(new Xxx())` 容易遗漏，用注解+类扫描更稳 | 思想来自 Spring `@EventListener/@Order` |
| **单测** | 用倒计时锁或者队列 assert 顺序；并发用 JUnit + Awaitility | 事件系统的回归 Bug 90% 来自顺序误改 |


> 写到这里，总算把“为什么这么设计”嚼明白。未来的我，如果你又忘了当初的思考，就回来翻这篇碎碎念 :)

