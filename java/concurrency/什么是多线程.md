# 什么是多线程

这篇笔记是为了帮我更清晰地理解“线程”到底是什么。从线程和进程的区别开始，再到线程的运行方式、状态变化、内存模型，最后才讲到如何在 Java 中创建线程。希望通过这种顺序，从原理到底层再到实践，逐步构建起对多线程的完整理解。

## 1. 线程和进程的区别

线程是程序执行的最小单位，是 CPU 调度的基本单位；进程是资源分配的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源，但有各自的执行栈。

Windows 下的进程和线程可以通过任务管理器查看，也可以通过命令行工具查看。

```bash
# Windows: 查看某个程序的进程与线程
tasklist | findstr chrome

# 杀死进程（Windows）
taskkill /PID <pid> /F
```

Linux 下的进程和线程可以通过 `ps` 命令查看，也可以使用 `top` 命令。

```bash
# Linux: 查看进程信息（包括线程）
# -e: 显示所有进程
# -L: 显示线程信息（Lightweight process）
# -f: 使用完整格式
ps -eLf | grep chrome

# 或者使用 top 并按 H 键显示线程（需指定进程 PID）
top -H -p <pid>

# 杀死进程（Linux）
# -9: 强制终止进程
kill -9 <pid>

# 杀死指定线程（Linux）
# 注意：tid 是线程 ID，可通过 ps -eLf 查到
kill -9 <tid>
```

- 进程隔离性强，线程切换更轻量；
- 线程共享内存，适合高频通信，但需注意线程安全。

| 维度     | 进程 (Process)                   | 线程 (Thread)               |
| -------- | -------------------------------- | --------------------------- |
| 核心角色 | 资源拥有者：地址空间、句柄、端口 | 指令执行者：占用 CPU 时间片 |
| 内存隔离 | 互相隔绝（跨进程需 IPC）         | 共享同一地址空间（更轻量）  |
| 创建成本 | 系统调用多、上下文大             | 调用栈 + 线程描述符，成本低 |
| 通信方式 | 管道/共享内存/Socket             | 共享变量直接通信            |

## 2. 线程是怎么被调度的

线程调度由操作系统负责，在 Java 层面无法强制指定线程的运行顺序。CPU 在多个线程之间切换的过程由调度器控制，核心机制主要包括以下几种：

- **时间片轮转（Time-Slicing）**：在单核 CPU 上，同时只能执行一个线程。操作系统为每个线程分配一个很短的时间片（如几十毫秒），轮流切换各线程执行，让它们“看起来”像是同时进行。
- **上下文切换（Context Switch）**：当调度器决定切换线程时，会保存当前线程的上下文（如程序计数器、寄存器状态、堆栈指针），然后加载下一个线程的上下文，恢复其运行状态。上下文切换是一种昂贵的操作，会带来性能开销。
- **抢占式调度（Preemptive Scheduling）**：当有更高优先级的线程就绪时，操作系统可以中断正在运行的线程，切换到高优先级线程执行。这种调度策略确保了系统响应性，但也可能导致线程“饿死”（长时间得不到运行机会）。
- **多级就绪队列（Multilevel Queue Scheduling）**：调度器可能会根据线程优先级、IO 密集型/CPU 密集型特征等因素，将线程分配到不同的队列，并使用不同的策略（如时间片长短）调度这些队列。

> CPU 从一个线程切换到另一个线程的过程称为调度。调度器需要做两件事：一是决定哪个线程接下来运行，二是保存和恢复线程的上下文信息，使得切换过程对线程来说是“无感知”的。

## 3. 线程有哪些状态

### 3.1 Java 线程状态

Java 中线程状态定义在 `Thread.State` 枚举中，共六种：

| Java 状态     | 含义                 | 示例场景            |
| ------------- | -------------------- | ------------------- |
| NEW           | 新建未启动           | `new Thread()`      |
| RUNNABLE      | 可运行（运行或就绪） | 获取 CPU 或排队执行 |
| BLOCKED       | 等待锁               | `synchronized` 冲突 |
| WAITING       | 无限期等待通知       | `join()` 无超时     |
| TIMED_WAITING | 限时等待             | `sleep(1000)` 等    |
| TERMINATED    | 运行完毕或异常退出   | `run()` 执行结束    |

注意：Java 的 RUNNABLE 同时包含了操作系统中的就绪态与运行态。

### 3.2 操作系统线程状态

操作系统中线程通常会经历以下几种状态，这些状态比 Java 的定义更底层一些：

| OS 状态    | 含义                                     |
| ---------- | ---------------------------------------- |
| New        | 线程对象被创建，但尚未调用 start()       |
| Ready      | 等待 CPU 分配时间片（处于就绪队列中）    |
| Running    | 正在执行，由 CPU 调度运行中              |
| Blocked    | 阻塞状态，等待某资源（如锁）             |
| Waiting    | 等待事件发生，不占用 CPU（如信号、消息） |
| Terminated | 线程执行结束，或被中断                   |

在 Java 中，多个操作系统状态会被合并映射到一个 Java 状态。例如：

- `RUNNABLE` 同时代表 OS 层面的 Ready 和 Running；
- `BLOCKED`、`WAITING`、`TIMED_WAITING` 都表示某种“阻塞”状态，但原因不同；
- `TERMINATED` 一一对应。

## 4. 线程的内存结构

在 Java 中，每个线程都有自己独立的内存空间用于执行任务，同时又依赖于共享的主内存与其他线程通信。搞清楚线程在运行时有哪些内存区域，是理解多线程可见性、线程安全和内存模型的基础。

### 4.1 线程在 JVM 中的主要内存区域

| 内存区域                 | 是否线程私有 | 作用说明                                   |
| ------------------------ | ------------ | ------------------------------------------ |
| 程序计数器               | 是           | 记录当前线程执行的字节码指令地址           |
| 虚拟机栈（栈内存）       | 是           | 保存方法调用相关信息、局部变量、操作数栈等 |
| 本地方法栈               | 是           | 支持 native 方法执行（如 C/C++）           |
| **工作内存（JMM 概念）** | 是           | 主内存中变量的线程本地副本（访问缓存）     |
| 堆内存（主内存）         | 否           | 所有线程共享，用于存放对象和类的实例数据   |

> 说明：除了“工作内存”是 Java 内存模型中的抽象，其余部分都是 JVM 运行时的真实结构。

### 4.2 工作内存和主内存的通信过程

Java 内存模型（JMM）定义了线程之间如何通过内存交互：

- 每个线程拥有自己的**工作内存**，保存主内存中共享变量的副本；
- 线程对变量的读写都在工作内存中进行，**并不会直接访问主内存**；
- 变量值只有在线程**同步回主内存**后，其他线程才能“看见”最新值。

这个模型像是线程拥有一个本地缓存快照：

- **读变量**：从主内存拷贝到工作内存；
- **写变量**：更新工作内存后再刷新回主内存；
- 线程之间不能访问彼此的工作内存，只能借助主内存通信。

这也是为什么并发程序中常会遇到“看不到最新值”的问题 —— 根源在于工作内存的隔离。

### 4.3 栈内存、线程安全与内存模型的关系

除了工作内存，线程还有自己的**虚拟机栈**，里面存放局部变量、方法返回地址等信息。这部分也完全线程私有，不会被其他线程访问。

因此可以这样理解：

> 线程私有的内存区域（如工作内存、栈）中变量是天然线程安全的；只有存放在共享堆内存中的变量，才需要同步控制。

例如：

- 方法内部的局部变量存在于栈中，多个线程各有一份，互不影响；
- 类的成员变量存在于堆中，多个线程可能同时访问，就可能引发并发问题。

### 4.4 示例：线程间通信的过程

```java
// 线程 A
x = 1; // 写入工作内存
// （稍后）同步到主内存

// 线程 B
// 从主内存读取 x（如果没同步，可能读到旧值）
System.out.println(x);
```

线程 A 对变量 `x` 的更新，不会立即对线程 B 可见，只有在工作内存同步回主内存后，线程 B 再从主内存加载，才能看到更新。

JMM 还规定了一系列 “**happens-before 规则**” 来保证内存可见性和执行顺序。例如：加锁解锁、线程启动和 join 都会建立这样的顺序关系。

## 5. 怎么创建线程

Java 提供了多种方式来创建和启动线程，最基础的是使用 `Thread` 类和 `Runnable` 接口。这些是所有多线程机制的基础，理解它们是入门的第一步。

### 5.1 使用 Thread 类

```java
Thread t = new Thread(() -> {
    System.out.println("Hello from thread: " + Thread.currentThread().getName());
});
t.start(); // 启动线程
```

- `Thread` 构造函数支持传入一个 `Runnable` 对象，也可以通过继承方式定义线程类。
- `start()` 方法才会真正创建一个新线程，执行 `run()` 方法体。
- 直接调用 `run()` 只是普通方法调用，不会新建线程。

### 5.2 实现 Runnable 接口

```java
class MyTask implements Runnable {
    public void run() {
        System.out.println("Running in: " + Thread.currentThread().getName());
    }
}

Thread t = new Thread(new MyTask());
t.start();
```

- 更推荐使用 `Runnable`，因为它不限制继承（不像继承 `Thread` 那样占用继承结构）。

### 5.3 常用线程方法

| 方法              | 说明                                                   |
| ----------------- | ------------------------------------------------------ |
| `start()`         | 启动线程，进入就绪状态，等待调度器调度执行             |
| `run()`           | 线程的任务逻辑方法，通常不直接调用它                   |
| `sleep(ms)`       | 当前线程暂停指定时间（不释放锁）                       |
| `join()`          | 当前线程等待另一个线程执行完毕                         |
| `interrupt()`     | 向目标线程发出“中断请求”，不是强制中断                 |
| `isAlive()`       | 判断线程是否还在运行中                                 |
| `setName(String)` | 设置线程名称，便于日志排查                             |
| `setDaemon(true)` | 设置为守护线程（例如垃圾回收器），主线程退出时自动结束 |

### 5.4 示例：等待线程执行完成

```java
Thread t = new Thread(() -> {
    try {
        Thread.sleep(1000);
        System.out.println("Thread finished.");
    } catch (InterruptedException e) {
        System.out.println("Thread was interrupted.");
    }
});

t.start();
t.join(); // 主线程等待子线程完成
System.out.println("Main thread resumes.");
```

## 6. 并发和并行的区别

**并发**：单核 CPU 通过时间片轮转，让多个线程“看起来”同时运行；

**并行**：多核 CPU 让多个线程**真正同时运行**。

> 并发强调任务结构优化， 并行强调执行效率最大化。

这部分属于扩展知识，可用于理解多线程的实际表现方式。
